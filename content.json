[{"title":"js学习笔记一","date":"2017-02-28T03:22:23.000Z","path":"2017/02/28/js学习笔记一/","text":"#####在html中使用JavaSCripts 把JavaScript插入到HTML页面中要使用&lt;script&gt;元素。使用这个元素可以把JavaScript嵌入到HTML页面中，让脚本与标记混合在一起；也可以包含外部的JavaScript文件。而我们需要注意的地方有： 在包含外部JavaScript文件时，必须将src属性设置为指向相应文件的URL。而这个文件既可以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件。所有&lt;script&gt;元素都会按照它们在页面中出现的先后顺序依次被解析。在不使用defer和async属性的情况下，只有在解析完前面&lt;script&gt;元素中的代码之后，才会开始解析后面&lt;script&gt;元素中的代码。 由于浏览器会先解析完不使用defer属性的&lt;script&gt;元素中的代码，然后再解析后面的内容，所以一般应该把&lt;script&gt;元素放在页面最后，即主要内容后面，&lt;/body&gt;标签前面。*使用defer属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照指定它们的顺序执行。 使用async属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。另外，使用&lt;noscript&gt;元素可以指定在不支持脚本的浏览器中显示的替代内容。但在启用了脚本的情况下，浏览器不会显示&lt;noscript&gt;元素中的任何内容。 #####严格模式在严格模式下，ECMAScript 3中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码：&quot;use strict&quot;;这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示（pragma），用于告诉支持的JavaScript引擎切换到严格模式。这是为不破坏ECMAScript 3语法而特意选定的语法。在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行： 1234function doSomething()&#123; \"use strict\"; //函数体&#125; 严格模式下，JavaScript的执行结果会有很大不同,支持严格模式的浏览器包括IE10+、Firefox 4+、Safari 5.1+、Opera 12+和Chrome. #####null和undefined 123456var message;//var age 并没有声明agealert(message);//\"undefined\"alert(age);// 产生错误alert(typeof message);//\"undefined\"alert(typeof age);\"undefined\" 对未初始化和未声明的变量执行typeof操作符都返回了undefined值；这个结果有其逻辑上的合理性。因为虽然这两种变量从技术角度看有本质区别，但实际上无论对哪种变量也不可能执行真正的操作。无论在什么情况下都没有必要把一个变量的值显式地设置为undefined，可是同样的规则对null却不适用。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。如下用法: 12345var car = null;...if(car!=null)&#123; do something for car;&#125; #####布尔值 javascript中的布尔值只有小写true和false 不能直接将1看为true,将0看为false,而应该统一用Boolean()函数来处理。 数据类型 转换后为true 转换后为false Boolean true false String 任何非空字符串 “”（空字符串） Number 任何非零数字值 0和NaN Object 任何对象 bull Undefined n/a [1] undefined Boolean()函数会自动执行转换，所以如下是成立的 1234var message = \"helloWorld\"if (message)&#123; alert(\"value is true\")&#125; #####数值 保存浮点数需要的内存空间是保存整数值的两倍。 var floatNum = 3.125e7; //等于31250000 在进行算术计算时其精确度远远不如整数。例如，0.1加0.2的结果不是0.3，而是0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。永远不要测试特定的浮点数 下面判断永远不要在代码中出现 123if(a+b==0.3)&#123; alert(&quot;you got 0.3&quot;);&#125; NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。用任意数值除以0即可得到NaN 任何涉及NaN的操作（例如NaN/10）都会返回NaN，这个特点在多步计算中有可能导致问题。NaN与任何值都不相等，包括NaN本身 isNaN()函数判断参数是否不是数值 有3个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。 123456var num1 = parseInt(\"1234blue\"); //1234var num2 = parseInt(\"blue1234\"); //NaNvar num3 = parseInt(\"0xA\"); //10(16进制）var num4 = parseInt(\"22.5\"); //22var num5 = parseInt(\"10\",16); //16 (按16进制解析)多数情况下，我们要解析的都是十进制数值，因此始终将10作为第二个参数是非常必要的。 #####字符串 单引号和双引号完全没有区别 字符串不可变，改变变量保存的字符串，其实是销毁加重新生成的过程。 使用toString()方法把任意值转为字符串，除了null和undefined。 #####object类型 Object的每个实例都具有下列属性和方法。 Constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是Object()。 hasOwnProperty（propertyName）：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty（”name”））。 isPrototypeOf（object）：用于检查传入的对象是否是另一个对象的原型（第5章将讨论原型）。 propertyIsEnumerable（propertyName）：用于检查给定的属性是否能够使用for-in语句（本章后面将会讨论）来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。 toLocaleString():返回对象的字符串表示，该字符串与执行环境的地区对应。 toString()：返回对象的字符串表示。 valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。 #####特殊的语句 使用label语句可以在代码中添加标签，以便将来使用，一般都要与for语句等循环语句配合使用。 1234567891011var num = 0;outermost:for(var i=0;i&lt;10;i++)&#123; for(var j=0;j&lt;10;j++)&#123; if(i==5 &amp;&amp; j==5 )&#123; break outermost; &#125; &#125;&#125;alert(num); //55 以上代码可以看出，label语句，使得break直接跳出了最外层的循环。 with语句的作用是将代码的作用域设置到一个特定的对象中。with语句的语法如下： with(expression) statement; 以下代码 123var qs = location.search.substring(1);var hostName = location.hostname;var url = location.href; 可以使用with语句改写成: 12345with(location)&#123; var qs = search.substring(1); var hostName = hostname; var url = href;&#125; 严格模式下不允许使用with语句，会造成性能下降，同时调试代码会有困难。不建议使用。 #####JS中的函数 任何函数在任何时候都可以通过return语句后跟要返回的值来实现返回值 函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型。也就是说，即便你定义的函数只接收两个参数，在调用这个函数时也未必一定要传递两个参数。可以传递一个、三个甚至不传递参数，而解析器永远不会有什么怨言。之所以会这样，原因是ECMAScript中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。如果这个数组中不包含任何元素，无所谓；如果包含多个元素，也没有问题。实际上，在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。 12345function sayHi()&#123; alert(\"Hello\" + arguments[0] + \".\" +arguments[1]); alert(arguments.length);&#125; 由于上条原因，JS中的函数没有重载 ###以上内容摘自JavaScript高级程序设计（第3版）前三章要点 版权声明本文由邢迪创作和发表，采用创作共用保留署名-非商业-禁止演绎4.0国际许可证。本文链接：http://xingdi.me/2017/02/28/js学习笔记一/","tags":[{"name":"html","slug":"html","permalink":"http://xingdi.me/tags/html/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://xingdi.me/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"http://xingdi.me/tags/前端/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://xingdi.me/tags/学习笔记/"}]},{"title":"编译和链接做了什么","date":"2017-01-17T05:58:24.000Z","path":"2017/01/17/编译和链接做了什么/","text":"代码由人类可读语言变为机器可读，需要经历以下几个步骤 预处理-&gt;编译-&gt;汇编-&gt;链接 这个过程在我们目前的开过中，基本都由IDE来完成了，以Xcode为例，我们还能在Run一个程序的过程中，看到提示进入到了哪个阶段，比如最后执行前会有一个Linking。越臃肿的工程，linking的时间越久，我们在这篇文章中会试图找出原因。 预处理预处理一般做了以下工作： - 删除所有的 #define 并展开所有宏定义 - 处理所有预编译条件，#if,#ifdef,#elif等 - 处理#include,将所有文件插入到该位置（递归引用，所以可能引起互相引用） - 删除所有注释 - 添加行号和文件名标识 (#2&quot;hello.c&quot;2) - 保留所有#pragma编译器指令 (比如结构体对齐标准) 预处理后的.i文件不包括任何宏，如果我们无法判断宏定义是否正确或头文件是否正确被包含，可以查看预编译后的文件。 编译编译过程将预处理完的文件进行语法分析与相关优化，生成出相应的汇编代码文件（注意是汇编代码）。目前gcc把预编译和编译合并成一个步骤，使用ccl完成 gcc -S hello.c -o hello.s &quot;对于C语言的代码来说，这个预编译和编译的程序是cc1，对于C++来说，有对应的程序叫做cc1plus；Objective-C是cc1obj；fortran是f771；Java是jc1。所以实际上gcc这个命令只是这些后台程序的包装，它会根据不同的参数要求去调用预编译编译程序cc1、汇编器as、链接器ld。&quot; --《程序员的自我修养：链接，装载和库》 汇编汇编器将汇编代码转变成机器可以执行的指令，每一个汇编语句对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译就可以了，“汇编”这个名字也来源于此。上面的汇编过程我们可以调用汇编器as来完成： $as hello.s –o hello.o 或者： 或者使用gcc命令从C源代码文件开始，经过预编译、编译和汇编直接输出目标文件（Object File）：$gcc –c hello.c –o hello.o 链接经过复杂的扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化，编译器忙活了这么多个步骤以后，源代码终于被编译成了目标代码。这会引发我们一个思考，目标代码中有变量定义在其他模块，怎么办？事实上，定义其他模块的全局变量和函数在最终运行时的绝对地址都要在最终链接的时候才能确定。所以现代的编译器可以将一个源代码文件编译成一个未链接的目标文件，然后由链接器最终将这些目标文件链接起来形成可执行文件。最基本的链接方式如下图所示： 每个模块的源代码文件（如.c）文件经过编译器编译成目标文件（Object File，一般扩展名为.o或.obj），目标文件和库（Library）一起链接形成最终可执行文件。 而最常见的库就是运行时库（Runtime Library），它是支持程序运行的基本函数的集合。库其实是一组目标文件的包，就是一些最常用的代码编译成目标文件后打包存放 比如我们在程序模块main.c中使用另外一个模块func.c中的函数foo()。我们在main.c模块中每一处调用foo的时候都必须确切知道foo这个函数的地址，但是由于每个模块都是单独编译的，在编译器编译main.c的时候它并不知道foo函数的地址，所以它暂时把这些调用foo的指令的目标地址搁置，等待最后链接的时候由链接器去将这些指令的目标地址修正。如果没有链接器，须要我们手工把每个调用foo的指令进行修正，则填入正确的foo函数地址。当func.c模块被重新编译，foo函数的地址有可能改变时，那么我们在main.c中所有使用到foo的地址的指令将要全部重新调整。这些繁琐的工作将成为程序员的噩梦。使用链接器，你可以直接引用其他模块的函数和全局变量而无须知道它们的地址，因为链接器在链接的时候，会根据你所引用的符号 foo，自动去相应的func.c模块查找foo的地址，然后将main.c模块中所有引用到foo的指令重新修正，让它们的目标地址为真正的foo函数的地址。这就是静态链接的最基本的过程和作用。 备注：本文摘自《程序员的自我修养：链接、装载与库》俞甲子 版权声明本文由邢迪创作和发表，采用创作共用保留署名-非商业-禁止演绎4.0国际许可证。本文链接：http://xingdi.me/2017/01/17/编译和链接做了什么/","tags":[{"name":"编译","slug":"编译","permalink":"http://xingdi.me/tags/编译/"},{"name":"链接","slug":"链接","permalink":"http://xingdi.me/tags/链接/"},{"name":"Propressing","slug":"Propressing","permalink":"http://xingdi.me/tags/Propressing/"},{"name":"Linking","slug":"Linking","permalink":"http://xingdi.me/tags/Linking/"}]},{"title":"开始使用markDown","date":"2017-01-11T06:59:41.000Z","path":"2017/01/11/开始使用markDown/","text":"决定开始使用markdown来写文章，这里记录下一些常用用方，以便以后写作需要时参考，会陆续纳入用到的一些语法和效果展示。 第一目标是标题 以上是####的效果，一个#最大，到六个#最小 六个#的效果 下面是代码块效果，三个 12这是在代码块中的内容可以换行 代码块中的语法高亮效果12NSString *tmp = @\"hello\";NSLog(@\"这是一个高亮测试%@\",tmp); 可能在编辑器中看不到实时预览效果，我们将在blog上进行验证，实现如下： 1NSString *tmp = @\"hello\"; 表格如果需要展示数据什么的，可以选择使用表格 header 1 header 3 cell 1 cell 2 cell 3 cell 4 cell 5 cell 6 实现如下。好像编辑器也无法预览表格效果 | header 1 | header 3 | | -------- | -------- | | cell 1 | cell 2 | | cell 3 | cell 4 | | cell 5 | cell 6 | 脚注生成一个脚注[^footnote].[^footnote]: 这里是 脚注 的 内容.生成第二个脚注[^2].[^2]: 这里是 第二个脚注 的 内容. 目录用 [TOC]来生成目录： [TOC] 注：脚注和目录TOC功能hexo暂不支持 段落 列表的作用 实现段落感 二级段落下面是一个tab位置 三级段落再加一个tab位置 同样是三级段落 下面是上面效果的原文 12345- 列表的作用 - 实现段落感 - 二级段落下面是一个tab位置 - 三级段落再加一个tab位置 - 同样是三级段落 也可以用* + - （星号，加号，减号） 这是一个段落 这是另一个 效果如下 12* 这是一个段落* 这是另一个 链接1这是一个[链接](xingdi.me) 这是一个链接,在macDown编辑器中可以直接将文字选中，按快捷键command+shift+k来生成链接格式，只需要在小括号中填入链接地址即可 图片引用图片引用使用![]()的方式 1![图片测试](http://siwangxinyuan.qiniudn.com/jianshu-42-1280x800-%5BDesktopNexus.com%5D.jpg?imageView/2/w/640/q/90) 上图中的7牛图床链接，640为图片的宽度，可以自定义设置 版权声明本文由邢迪创作和发表，采用创作共用保留署名-非商业-禁止演绎4.0国际许可证。本文链接：http://xingdi.me/2017/01/11/开始使用markDown/","tags":[{"name":"markdown","slug":"markdown","permalink":"http://xingdi.me/tags/markdown/"},{"name":"macdown","slug":"macdown","permalink":"http://xingdi.me/tags/macdown/"},{"name":"blog","slug":"blog","permalink":"http://xingdi.me/tags/blog/"},{"name":"开发记录","slug":"开发记录","permalink":"http://xingdi.me/tags/开发记录/"}]},{"title":"helloHexo","date":"2017-01-09T09:48:54.000Z","path":"2017/01/09/helloHexo/","text":"2017狠下心买了域名，虽然没多少钱。以后博客就在这里了。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://xingdi.me/tags/随笔/"}]}]