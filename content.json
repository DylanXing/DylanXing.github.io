[{"title":"编译和链接做了什么","date":"2017-01-17T05:58:24.000Z","path":"2017/01/17/编译和链接做了什么/","text":"代码由人类可读语言变为机器可读，需要经历以下几个步骤 预处理-&gt;编译-&gt;汇编-&gt;链接 这个过程在我们目前的开过中，基本都由IDE来完成了，以Xcode为例，我们还能在Run一个程序的过程中，看到提示进入到了哪个阶段，比如最后执行前会有一个Linking。越臃肿的工程，linking的时间越久，我们在这篇文章中会试图找出原因。 预处理预处理一般做了以下工作： - 删除所有的 #define 并展开所有宏定义 - 处理所有预编译条件，#if,#ifdef,#elif等 - 处理#include,将所有文件插入到该位置（递归引用，所以可能引起互相引用） - 删除所有注释 - 添加行号和文件名标识 (#2&quot;hello.c&quot;2) - 保留所有#pragma编译器指令 (比如结构体对齐标准) 预处理后的.i文件不包括任何宏，如果我们无法判断宏定义是否正确或头文件是否正确被包含，可以查看预编译后的文件。 编译编译过程将预处理完的文件进行语法分析与相关优化，生成出相应的汇编代码文件（注意是汇编代码）。目前gcc把预编译和编译合并成一个步骤，使用ccl完成 gcc -S hello.c -o hello.s &quot;对于C语言的代码来说，这个预编译和编译的程序是cc1，对于C++来说，有对应的程序叫做cc1plus；Objective-C是cc1obj；fortran是f771；Java是jc1。所以实际上gcc这个命令只是这些后台程序的包装，它会根据不同的参数要求去调用预编译编译程序cc1、汇编器as、链接器ld。&quot; --《程序员的自我修养：链接，装载和库》 汇编汇编器将汇编代码转变成机器可以执行的指令，每一个汇编语句对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译就可以了，“汇编”这个名字也来源于此。上面的汇编过程我们可以调用汇编器as来完成： $as hello.s –o hello.o 或者： 或者使用gcc命令从C源代码文件开始，经过预编译、编译和汇编直接输出目标文件（Object File）：$gcc –c hello.c –o hello.o 链接经过复杂的扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化，编译器忙活了这么多个步骤以后，源代码终于被编译成了目标代码。这会引发我们一个思考，目标代码中有变量定义在其他模块，怎么办？事实上，定义其他模块的全局变量和函数在最终运行时的绝对地址都要在最终链接的时候才能确定。所以现代的编译器可以将一个源代码文件编译成一个未链接的目标文件，然后由链接器最终将这些目标文件链接起来形成可执行文件。最基本的链接方式如下图所示： 每个模块的源代码文件（如.c）文件经过编译器编译成目标文件（Object File，一般扩展名为.o或.obj），目标文件和库（Library）一起链接形成最终可执行文件。 而最常见的库就是运行时库（Runtime Library），它是支持程序运行的基本函数的集合。库其实是一组目标文件的包，就是一些最常用的代码编译成目标文件后打包存放 比如我们在程序模块main.c中使用另外一个模块func.c中的函数foo()。我们在main.c模块中每一处调用foo的时候都必须确切知道foo这个函数的地址，但是由于每个模块都是单独编译的，在编译器编译main.c的时候它并不知道foo函数的地址，所以它暂时把这些调用foo的指令的目标地址搁置，等待最后链接的时候由链接器去将这些指令的目标地址修正。如果没有链接器，须要我们手工把每个调用foo的指令进行修正，则填入正确的foo函数地址。当func.c模块被重新编译，foo函数的地址有可能改变时，那么我们在main.c中所有使用到foo的地址的指令将要全部重新调整。这些繁琐的工作将成为程序员的噩梦。使用链接器，你可以直接引用其他模块的函数和全局变量而无须知道它们的地址，因为链接器在链接的时候，会根据你所引用的符号 foo，自动去相应的func.c模块查找foo的地址，然后将main.c模块中所有引用到foo的指令重新修正，让它们的目标地址为真正的foo函数的地址。这就是静态链接的最基本的过程和作用。 备注：本文摘自《程序员的自我修养：链接、装载与库》俞甲子 版权声明本文由邢迪创作和发表，采用创作共用保留署名-非商业-禁止演绎4.0国际许可证。本文链接：http://xingdi.me/2017/01/17/编译和链接做了什么/","tags":[{"name":"编译","slug":"编译","permalink":"http://xingdi.me/tags/编译/"},{"name":"链接","slug":"链接","permalink":"http://xingdi.me/tags/链接/"},{"name":"Propressing","slug":"Propressing","permalink":"http://xingdi.me/tags/Propressing/"},{"name":"Linking","slug":"Linking","permalink":"http://xingdi.me/tags/Linking/"}]},{"title":"开始使用markDown","date":"2017-01-11T06:59:41.000Z","path":"2017/01/11/开始使用markDown/","text":"决定开始使用markdown来写文章，这里记录下一些常用用方，以便以后写作需要时参考，会陆续纳入用到的一些语法和效果展示。 第一目标是标题 以上是####的效果，一个#最大，到六个#最小 六个#的效果 下面是代码块效果，三个 12这是在代码块中的内容可以换行 代码块中的语法高亮效果12NSString *tmp = @\"hello\";NSLog(@\"这是一个高亮测试%@\",tmp); 可能在编辑器中看不到实时预览效果，我们将在blog上进行验证，实现如下： 1NSString *tmp = @\"hello\"; 表格如果需要展示数据什么的，可以选择使用表格 header 1 header 3 cell 1 cell 2 cell 3 cell 4 cell 5 cell 6 实现如下。好像编辑器也无法预览表格效果 | header 1 | header 3 | | -------- | -------- | | cell 1 | cell 2 | | cell 3 | cell 4 | | cell 5 | cell 6 | 脚注生成一个脚注[^footnote].[^footnote]: 这里是 脚注 的 内容.生成第二个脚注[^2].[^2]: 这里是 第二个脚注 的 内容. 目录用 [TOC]来生成目录： [TOC] 注：脚注和目录TOC功能hexo暂不支持 段落 列表的作用 实现段落感 二级段落下面是一个tab位置 三级段落再加一个tab位置 同样是三级段落 下面是上面效果的原文 12345- 列表的作用 - 实现段落感 - 二级段落下面是一个tab位置 - 三级段落再加一个tab位置 - 同样是三级段落 也可以用* + - （星号，加号，减号） 这是一个段落 这是另一个 效果如下 12* 这是一个段落* 这是另一个 链接1这是一个[链接](xingdi.me) 这是一个链接,在macDown编辑器中可以直接将文字选中，按快捷键command+shift+k来生成链接格式，只需要在小括号中填入链接地址即可 图片引用图片引用使用![]()的方式 1![图片测试](http://siwangxinyuan.qiniudn.com/jianshu-42-1280x800-%5BDesktopNexus.com%5D.jpg?imageView/2/w/640/q/90) 上图中的7牛图床链接，640为图片的宽度，可以自定义设置 版权声明本文由邢迪创作和发表，采用创作共用保留署名-非商业-禁止演绎4.0国际许可证。本文链接：http://xingdi.me/2017/01/11/开始使用markDown/","tags":[{"name":"markdown","slug":"markdown","permalink":"http://xingdi.me/tags/markdown/"},{"name":"macdown","slug":"macdown","permalink":"http://xingdi.me/tags/macdown/"},{"name":"blog","slug":"blog","permalink":"http://xingdi.me/tags/blog/"},{"name":"开发记录","slug":"开发记录","permalink":"http://xingdi.me/tags/开发记录/"}]},{"title":"helloHexo","date":"2017-01-09T09:48:54.000Z","path":"2017/01/09/helloHexo/","text":"2017狠下心买了域名，虽然没多少钱。以后博客就在这里了。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://xingdi.me/tags/随笔/"}]}]