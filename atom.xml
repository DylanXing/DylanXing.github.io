<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>邢迪的平行时空</title>
  <subtitle>伪极客，Karen&#39;s Lover</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xingdi.me/"/>
  <updated>2017-03-02T07:38:09.000Z</updated>
  <id>http://xingdi.me/</id>
  
  <author>
    <name>邢迪的平行时空</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mac升级系统后没有任何来源选项怎么办</title>
    <link href="http://xingdi.me/2017/03/02/mac%E5%8D%87%E7%BA%A7%E7%B3%BB%E7%BB%9F%E5%90%8E%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95%E6%9D%A5%E6%BA%90%E9%80%89%E9%A1%B9%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <id>http://xingdi.me/2017/03/02/mac升级系统后没有任何来源选项怎么办/</id>
    <published>2017-03-02T07:24:22.000Z</published>
    <updated>2017-03-02T07:38:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>打开终端输入<br><code>sudo spctl --master-diable</code><br>即可</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打开终端输入&lt;br&gt;&lt;code&gt;sudo spctl --master-diable&lt;/code&gt;&lt;br&gt;即可&lt;/p&gt;

    
    </summary>
    
    
      <category term="任何来源" scheme="http://xingdi.me/tags/%E4%BB%BB%E4%BD%95%E6%9D%A5%E6%BA%90/"/>
    
      <category term="macOS 10.12" scheme="http://xingdi.me/tags/macOS-10-12/"/>
    
      <category term="mac系统" scheme="http://xingdi.me/tags/mac%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>js学习笔记二</title>
    <link href="http://xingdi.me/2017/02/28/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <id>http://xingdi.me/2017/02/28/js学习笔记二/</id>
    <published>2017-02-28T07:38:01.000Z</published>
    <updated>2017-02-28T09:16:05.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="基本数据类型和引用类型"><a href="#基本数据类型和引用类型" class="headerlink" title="基本数据类型和引用类型"></a>基本数据类型和引用类型</h5><ul>
<li>JS中有5种基本数据类型Undefined、Null、Boolean、Number和String。这5种基本数据类型是按值访问的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> num2 = num1;</div></pre></td></tr></table></figure>
<p>以上<code>num1</code>和<code>num2</code>在内存中是两个独立的空间。</p>
<ul>
<li>引用类型是保存在内存中的对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"><span class="keyword">var</span> obj2 = obj1;</div><div class="line">obj1.name = <span class="string">"Dylan"</span>;</div><div class="line">alert(obj2.name); <span class="comment">//"Dylan"</span></div></pre></td></tr></table></figure>
<p>如上，引用类型中的赋值操作，其实引用的是同一个对象。都在堆内存中。<br>以上两种区别在函数传参时尤为重要。<br>对比以下代码</p>
<p>代码1 (基本数据类型)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">	num += <span class="number">10</span>;</div><div class="line">	<span class="keyword">return</span> num;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> count = <span class="number">20</span>;</div><div class="line"><span class="keyword">var</span> result = addTen(count);</div><div class="line">alert(count);		<span class="comment">//20，没有变化</span></div><div class="line">alert(result);	<span class="comment">//30;</span></div></pre></td></tr></table></figure>
<p>代码2 (引用数据类型)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">	obj.name = <span class="string">"Dylan"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">setName(person);</div><div class="line">alert(person.name);	<span class="comment">//"Dylan"</span></div></pre></td></tr></table></figure>
<h5 id="js中没有块级作用域"><a href="#js中没有块级作用域" class="headerlink" title="js中没有块级作用域"></a>js中没有块级作用域</h5><p>这里是在一个if语句中定义了变量color。如果是在C、C++或Java中，color会在if语句执行完毕后被销毁。但在JavaScript中，i f语句中的变量声明会将变量添加到当前的执行环境（在这里是全局环境）中。在使用for语句时尤其要牢记这一差异</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</div><div class="line">	<span class="keyword">var</span> color = <span class="string">'blue'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(color);		<span class="comment">//'blue'</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(i);		<span class="comment">//10</span></div></pre></td></tr></table></figure>
<p>上面这段代码也没毛病。<br>使用var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在with语句中，最接近的环境是函数环境。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境。如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> sum = num1+num2;</div><div class="line">	<span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = add(<span class="number">10</span>,<span class="number">20</span>);	<span class="comment">//30</span></div><div class="line">alert(sum);	<span class="comment">//报错！</span></div></pre></td></tr></table></figure>
<h5 id="创建Object实例的两种方法"><a href="#创建Object实例的两种方法" class="headerlink" title="创建Object实例的两种方法"></a>创建Object实例的两种方法</h5><p>方法1：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">person.name = <span class="string">"dylan"</span>;</div><div class="line">person.age = <span class="number">28</span>;</div></pre></td></tr></table></figure>
<p>方法2：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">	<span class="attr">name</span> : <span class="string">"dylan"</span>,</div><div class="line">	<span class="attr">age</span>  : <span class="number">29</span>	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p><code>var person = {} 等价于 var person = new Object()</code></p>
</li>
<li><p><code>person[&quot;name&quot;] 等价于 person.name</code></p>
</li>
<li><p><code>if (typeof person.name == &quot;string&quot;)来判断对象是否有某个属性</code></p>
</li>
</ul>
<h5 id="JS中的数组"><a href="#JS中的数组" class="headerlink" title="JS中的数组"></a>JS中的数组</h5><p>可以用以下方法创建数组，和lua不同，数组索引从0开始</p>
<ul>
<li><code>var colors = new Array()</code></li>
<li><code>var colors = new Array(20)</code></li>
<li><code>var colors = new Array(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;)</code></li>
<li><code>var colors = Array(&quot;dylan&quot;)</code> //可以省略new</li>
<li><p><code>var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</code></p>
</li>
<li><p>数组的length不是可读的，可以通过<code>colors.length=1</code>来移除数组后面的项。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//判断是否是数组</div><div class="line">if(value instanceof Array)&#123;</div><div class="line">	</div><div class="line">&#125;</div><div class="line">或者用最新的</div><div class="line">if(Array.isArray(value))&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>可以使用<code>join()</code>方法来分隔数组生成字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</div><div class="line">alert(colors.join(<span class="string">"$"</span>));	<span class="comment">//"red$green$blue"</span></div></pre></td></tr></table></figure>
<ul>
<li>数组支持<code>push</code>和<code>pop</code>的栈方法（后入先出）。</li>
<li>数组利用<code>shift</code>和<code>push</code>来实现队列方法（先入先出）。</li>
<li><code>reverse()</code>方法反转数组排序，12345变成54321</li>
<li><code>sort()</code>方法默认升序排列，即由小到大。全部转为字符串比较。所以默认比较方法不准确，因为从字符串来讲，10是在5前面的。好在sort可以接收一个比较函数作为参数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1,value2</span>)</span>&#123;</div><div class="line">	<span class="keyword">if</span>(value1 &lt; value2)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(value1 &gt; value2)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> values = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>];</div><div class="line">values.sort(compare);</div><div class="line">alert(values);	<span class="comment">//0,1,5,10,15</span></div><div class="line">更改compare中的<span class="number">-1</span>和<span class="number">1</span>,sort则从大到小排列</div></pre></td></tr></table></figure>
<ul>
<li><code>concat()</code>方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给<code>concat()</code>方法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给<code>concat()</code>方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</div><div class="line"><span class="keyword">var</span> colors = colors.concat(<span class="string">"yellow"</span>,[<span class="string">"black"</span>,<span class="string">"brown"</span>]);</div><div class="line">alert (colors);	<span class="comment">//red,green.blue</span></div><div class="line">alert(colors2);	<span class="comment">//red,green,blue,yellow,black,brown</span></div></pre></td></tr></table></figure>
<ul>
<li><code>slice()</code>能够基于当前数组中的一或多个项创建一个新数组。<code>slice()</code>方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，<code>slice()</code>方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项一一但不包括结束位置的项。注意，<code>slice()</code>方法不会影响原始数组。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>,<span class="string">"yellow"</span>,<span class="string">"purple"</span>];</div><div class="line"><span class="keyword">var</span> colors2 = colors.slice(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> colors3 = colors.slice(<span class="number">1</span>,<span class="number">4</span>);</div><div class="line"></div><div class="line">alert(colors2);	<span class="comment">//green,blue,yellow,purple</span></div><div class="line">alert(colors3);	<span class="comment">//green,blue,yellow</span></div></pre></td></tr></table></figure>
<ul>
<li><code>splice()</code>要算是最强大的数组方法了，它有很多种用法。<code>splice()</code>的主要用途是向数组的中部插入项，但使用这种方法的方式则有如下3种。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1、删除：可以删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数。例如，spl ice（0，2）会删除数组中的前两项。</div><div class="line"></div><div class="line">2、插入：可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，splice（2,0, &quot;red&quot;, &quot;green&quot;）会从当前数组的位置2开始插入字符串&quot;red&quot;和&quot;green&quot;。</div><div class="line"></div><div class="line">3、替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice（2,1, &quot;red&quot;, &quot;green&quot;）会删除当前数组位置2的项，然后再从位置2开始插入字符串&quot;red&quot;和&quot;green&quot;。</div></pre></td></tr></table></figure>
<h5 id="数组的迭代"><a href="#数组的迭代" class="headerlink" title="数组的迭代"></a>数组的迭代</h5><p>JS为数组定义了5个迭代方法。<br>每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响this的值。传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身(item,index,array)。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响访问的返回值。以下是这5个迭代方法的作用：</p>
<ul>
<li>every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。</li>
<li>filter():对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。</li>
<li>forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。</li>
<li>map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
<li>some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> everyResult = numbers.every(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> (item &gt;<span class="number">2</span> );</div><div class="line">&#125;);</div><div class="line"></div><div class="line">alert(everyResult); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>一般我们只需要用forEach来对数组做遍历即可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">numbers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</div><div class="line">	...</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h6 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h6><p>本文由<a href="xingdi.me">邢迪</a>创作和发表，采用<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br>本文链接：<a href="http://xingdi.me/2017/02/28/js学习笔记二/">http://xingdi.me/2017/02/28/js学习笔记二/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;基本数据类型和引用类型&quot;&gt;&lt;a href=&quot;#基本数据类型和引用类型&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型和引用类型&quot;&gt;&lt;/a&gt;基本数据类型和引用类型&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;JS中有5种基本数据类型Undefined、Null、B
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://xingdi.me/tags/JavaScript/"/>
    
      <category term="学习笔记" scheme="http://xingdi.me/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="http://xingdi.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="web开发" scheme="http://xingdi.me/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="html" scheme="http://xingdi.me/tags/html/"/>
    
      <category term="JS数组" scheme="http://xingdi.me/tags/JS%E6%95%B0%E7%BB%84/"/>
    
      <category term="JS对象" scheme="http://xingdi.me/tags/JS%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>js学习笔记一</title>
    <link href="http://xingdi.me/2017/02/28/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://xingdi.me/2017/02/28/js学习笔记一/</id>
    <published>2017-02-28T03:22:23.000Z</published>
    <updated>2017-02-28T07:33:41.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="在html中使用JavaSCripts"><a href="#在html中使用JavaSCripts" class="headerlink" title="在html中使用JavaSCripts"></a>在html中使用JavaSCripts</h5><p>把JavaScript插入到HTML页面中要使用<code>&lt;script&gt;</code>元素。使用这个元素可以把JavaScript嵌入到HTML页面中，让脚本与标记混合在一起；也可以包含外部的JavaScript文件。而我们需要注意的地方有：</p>
<ul>
<li><p>在包含外部JavaScript文件时，必须将src属性设置为指向相应文件的URL。而这个文件既可以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件。所有<code>&lt;script&gt;</code>元素都会按照它们在页面中出现的先后顺序依次被解析。在不使用defer和async属性的情况下，只有在解析完前面<code>&lt;script&gt;</code>元素中的代码之后，才会开始解析后面<code>&lt;script&gt;</code>元素中的代码。</p>
</li>
<li><p>由于浏览器会先解析完不使用<code>defer</code>属性的<code>&lt;script&gt;</code>元素中的代码，然后再解析后面的内容，<br>所以一般应该把<code>&lt;script&gt;</code>元素放在页面最后，即主要内容后面，<code>&lt;/body&gt;</code>标签前面。<br>*使用<code>defer</code>属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照指定它们的顺序执行。</p>
</li>
<li>使用<code>async</code>属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。<br>另外，使用<code>&lt;noscript&gt;</code>元素可以指定在不支持脚本的浏览器中显示的替代内容。但在启用了脚本的情况下，浏览器不会显示<code>&lt;noscript&gt;</code>元素中的任何内容。</li>
</ul>
<h5 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h5><p>在严格模式下，ECMAScript 3中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码：<br><code>&quot;use strict&quot;;</code><br>这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示（pragma），用于告诉支持的JavaScript引擎切换到严格模式。这是为不破坏ECMAScript 3语法而特意选定的语法。<br>在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">	"use strict"</span>;</div><div class="line">	<span class="comment">//函数体</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>严格模式下，JavaScript的执行结果会有很大不同,支持严格模式的浏览器包括IE10+、Firefox 4+、Safari 5.1+、Opera 12+和Chrome.</p>
<h5 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message;</div><div class="line"><span class="comment">//var age  并没有声明age</span></div><div class="line">alert(message);<span class="comment">//"undefined"</span></div><div class="line">alert(age);<span class="comment">// 产生错误</span></div><div class="line">alert(<span class="keyword">typeof</span> message);<span class="comment">//"undefined"</span></div><div class="line">alert(<span class="keyword">typeof</span> age);<span class="string">"undefined"</span></div></pre></td></tr></table></figure>
<p>对未初始化和未声明的变量执行<code>typeof</code>操作符都返回了<code>undefined</code>值；这个结果有其逻辑上的合理性。因为虽然这两种变量从技术角度看有本质区别，但实际上无论对哪种变量也不可能执行真正的操作。无论在什么情况下都没有必要把一个变量的值显式地设置为<code>undefined</code>，可是同样的规则对<code>null</code>却不适用。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存<code>null</code>值。如下用法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> car = <span class="literal">null</span>;</div><div class="line">...</div><div class="line">if(car!=<span class="literal">null</span>)&#123;</div><div class="line">	<span class="keyword">do</span> something <span class="keyword">for</span> car;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h5><ul>
<li>javascript中的布尔值只有小写<code>true</code>和<code>false</code></li>
<li>不能直接将1看为<code>true</code>,将0看为<code>false</code>,而应该统一用Boolean()函数来处理。</li>
</ul>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>转换后为true</th>
<th>转换后为false</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>任何非空字符串</td>
<td>“”（空字符串）</td>
</tr>
<tr>
<td>Number</td>
<td>任何非零数字值</td>
<td>0和NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任何对象</td>
<td>bull</td>
</tr>
<tr>
<td>Undefined</td>
<td>n/a [1]</td>
<td>undefined</td>
</tr>
</tbody>
</table>
<p>Boolean()函数会自动执行转换，所以如下是成立的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">"helloWorld"</span></div><div class="line"><span class="keyword">if</span> (message)&#123;</div><div class="line">	alert(<span class="string">"value is true"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h5><ul>
<li>保存浮点数需要的内存空间是保存整数值的两倍。</li>
<li>var floatNum = 3.125e7; //等于31250000</li>
<li>在进行算术计算时其精确度远远不如整数。例如，0.1加0.2的结果不是0.3，而是0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。<code>永远不要测试特定的浮点数</code></li>
</ul>
<p>下面判断永远不要在代码中出现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if(a+b==0.3)&#123;</div><div class="line">	alert(&quot;you got 0.3&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p><code>NaN</code>，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。用任意数值除以0即可得到<code>NaN</code></p>
</li>
<li><p>任何涉及NaN的操作（例如NaN/10）都会返回NaN，这个特点在多步计算中有可能导致问题。NaN与任何值都不相等，包括NaN本身</p>
</li>
<li><code>isNaN()</code>函数判断参数是否<code>不是数值</code></li>
<li>有3个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">"1234blue"</span>); <span class="comment">//1234</span></div><div class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">"blue1234"</span>); <span class="comment">//NaN</span></div><div class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">"0xA"</span>); <span class="comment">//10(16进制）</span></div><div class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="string">"22.5"</span>); <span class="comment">//22</span></div><div class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseInt</span>(<span class="string">"10"</span>,<span class="number">16</span>); <span class="comment">//16 (按16进制解析)</span></div><div class="line">多数情况下，我们要解析的都是十进制数值，因此始终将<span class="number">10</span>作为第二个参数是非常必要的。</div></pre></td></tr></table></figure>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><ul>
<li>单引号和双引号完全没有区别</li>
<li>字符串不可变，改变变量保存的字符串，其实是销毁加重新生成的过程。</li>
<li>使用<code>toString()</code>方法把任意值转为字符串，除了null和undefined。</li>
</ul>
<h5 id="object类型"><a href="#object类型" class="headerlink" title="object类型"></a>object类型</h5><p>Object的每个实例都具有下列属性和方法。</p>
<ul>
<li>Constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是Object()。</li>
<li>hasOwnProperty（propertyName）：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty（”name”））。</li>
<li>isPrototypeOf（object）：用于检查传入的对象是否是另一个对象的原型（第5章将讨论原型）。</li>
<li>propertyIsEnumerable（propertyName）：用于检查给定的属性是否能够使用for-in语句（本章后面将会讨论）来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。</li>
<li>toLocaleString():返回对象的字符串表示，该字符串与执行环境的地区对应。</li>
<li>toString()：返回对象的字符串表示。</li>
<li>valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。</li>
</ul>
<h5 id="特殊的语句"><a href="#特殊的语句" class="headerlink" title="特殊的语句"></a>特殊的语句</h5><ul>
<li>使用label语句可以在代码中添加标签，以便将来使用，一般都要与for语句等循环语句配合使用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</div><div class="line">outermost:</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123;</div><div class="line">		<span class="keyword">if</span>(i==<span class="number">5</span> &amp;&amp; j==<span class="number">5</span> )&#123;</div><div class="line">			<span class="keyword">break</span> outermost;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(num);  <span class="comment">//55</span></div></pre></td></tr></table></figure>
<p>以上代码可以看出，label语句，使得break直接跳出了最外层的循环。</p>
<ul>
<li>with语句的作用是将代码的作用域设置到一个特定的对象中。with语句的语法如下：<br>  <code>with(expression) statement;</code></li>
</ul>
<p>以下代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> qs = location.search.substring(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> hostName = location.hostname;</div><div class="line"><span class="keyword">var</span> url = location.href;</div></pre></td></tr></table></figure>
<p>可以使用with语句改写成:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span>(location)&#123;</div><div class="line">	<span class="keyword">var</span> qs = search.substring(<span class="number">1</span>);</div><div class="line">	<span class="keyword">var</span> hostName = hostname;</div><div class="line">	<span class="keyword">var</span> url = href;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>严格模式下不允许使用with语句，会造成性能下降，同时调试代码会有困难。不建议使用。</li>
</ul>
<h5 id="JS中的函数"><a href="#JS中的函数" class="headerlink" title="JS中的函数"></a>JS中的函数</h5><ul>
<li>任何函数在任何时候都可以通过return语句后跟要返回的值来实现返回值</li>
<li>函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型。也就是说，即便你定义的函数只接收两个参数，在调用这个函数时也未必一定要传递两个参数。可以传递一个、三个甚至不传递参数，而解析器永远不会有什么怨言。之所以会这样，原因是ECMAScript中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。如果这个数组中不包含任何元素，无所谓；如果包含多个元素，也没有问题。实际上，在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="string">"Hello"</span> + <span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="string">"."</span> +<span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">	alert(<span class="built_in">arguments</span>.length);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>由于上条原因，JS中的函数<code>没有重载</code></li>
</ul>
<h3 id="以上内容摘自JavaScript高级程序设计（第3版）前三章要点"><a href="#以上内容摘自JavaScript高级程序设计（第3版）前三章要点" class="headerlink" title="以上内容摘自JavaScript高级程序设计（第3版）前三章要点"></a>以上内容摘自JavaScript高级程序设计（第3版）前三章要点</h3><h6 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h6><p>本文由<a href="xingdi.me">邢迪</a>创作和发表，采用<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br>本文链接：<a href="http://xingdi.me/2017/02/28/js学习笔记一/">http://xingdi.me/2017/02/28/js学习笔记一/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;在html中使用JavaSCripts&quot;&gt;&lt;a href=&quot;#在html中使用JavaSCripts&quot; class=&quot;headerlink&quot; title=&quot;在html中使用JavaSCripts&quot;&gt;&lt;/a&gt;在html中使用JavaSCripts&lt;/h5&gt;&lt;p&gt;把J
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://xingdi.me/tags/JavaScript/"/>
    
      <category term="学习笔记" scheme="http://xingdi.me/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="http://xingdi.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="html" scheme="http://xingdi.me/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>编译和链接做了什么</title>
    <link href="http://xingdi.me/2017/01/17/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://xingdi.me/2017/01/17/编译和链接做了什么/</id>
    <published>2017-01-17T05:58:24.000Z</published>
    <updated>2017-01-17T08:50:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>代码由人类可读语言变为机器可读，需要经历以下几个步骤</p>
<p><code>预处理-&gt;编译-&gt;汇编-&gt;链接</code></p>
<p>这个过程在我们目前的开过中，基本都由IDE来完成了，以Xcode为例，我们还能在Run一个程序的过程中，看到提示进入到了哪个阶段，比如最后执行前会有一个Linking。越臃肿的工程，linking的时间越久，我们在这篇文章中会试图找出原因。</p>
<h5 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h5><p>预处理一般做了以下工作：</p>
<pre><code>- 删除所有的 #define 并展开所有宏定义
- 处理所有预编译条件，#if,#ifdef,#elif等
- 处理#include,将所有文件插入到该位置（递归引用，所以可能引起互相引用）
- 删除所有注释
- 添加行号和文件名标识 (#2&quot;hello.c&quot;2)
- 保留所有#pragma编译器指令 (比如结构体对齐标准)
</code></pre><p>预处理后的.i文件不包括任何宏，如果我们无法判断宏定义是否正确或头文件是否正确被包含，可以查看预编译后的文件。</p>
<h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><p>编译过程将预处理完的文件进行语法分析与相关优化，生成出相应的汇编代码文件（注意是汇编代码）。目前gcc把预编译和编译合并成一个步骤，使用ccl完成</p>
<p><code>gcc -S hello.c -o hello.s</code></p>
<pre><code>&quot;对于C语言的代码来说，这个预编译和编译的程序是cc1，对于C++来说，有对应的程序叫做cc1plus；Objective-C是cc1obj；fortran是f771；Java是jc1。所以实际上gcc这个命令只是这些后台程序的包装，它会根据不同的参数要求去调用预编译编译程序cc1、汇编器as、链接器ld。&quot;
                --《程序员的自我修养：链接，装载和库》
</code></pre><h5 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h5><p>汇编器将汇编代码转变成机器可以执行的指令，每一个汇编语句对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译就可以了，“汇编”这个名字也来源于此。上面的汇编过程我们可以调用汇编器as来完成：</p>
<p><code>$as hello.s –o hello.o</code></p>
<p>或者：</p>
<p>或者使用gcc命令从C源代码文件开始，经过预编译、编译和汇编直接输出目标文件（Object File）：<br><code>$gcc –c hello.c –o hello.o</code></p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>经过复杂的扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化，编译器忙活了这么多个步骤以后，源代码终于被编译成了目标代码。这会引发我们一个思考，目标代码中有变量定义在其他模块，怎么办？事实上，定义其他模块的全局变量和函数在最终运行时的绝对地址都要在最终链接的时候才能确定。所以现代的编译器可以将一个源代码文件编译成一个未链接的目标文件，然后由链接器最终将这些目标文件链接起来形成可执行文件。<br>最基本的链接方式如下图所示：<br><img src="http://siwangxinyuan.qiniudn.com/jianshu-42-1280x800-%5BDesktopNexus.com%5D.jpg?imageView/2/w/640/q/90" alt="链接过程"></p>
<p>每个模块的源代码文件（如.c）文件经过编译器编译成目标文件（Object File，一般扩展名为.o或.obj），目标文件和库（Library）一起链接形成最终可执行文件。</p>
<pre><code>而最常见的库就是运行时库（Runtime Library），它是支持程序运行的基本函数的集合。库其实是一组目标文件的包，就是一些最常用的代码编译成目标文件后打包存放

比如我们在程序模块main.c中使用另外一个模块func.c中的函数foo()。我们在main.c模块中每一处调用foo的时候都必须确切知道foo这个函数的地址，但是由于每个模块都是单独编译的，在编译器编译main.c的时候它并不知道foo函数的地址，所以它暂时把这些调用foo的指令的目标地址搁置，等待最后链接的时候由链接器去将这些指令的目标地址修正。如果没有链接器，须要我们手工把每个调用foo的指令进行修正，则填入正确的foo函数地址。当func.c模块被重新编译，foo函数的地址有可能改变时，那么我们在main.c中所有使用到foo的地址的指令将要全部重新调整。这些繁琐的工作将成为程序员的噩梦。使用链接器，你可以直接引用其他模块的函数和全局变量而无须知道它们的地址，因为链接器在链接的时候，会根据你所引用的符号 foo，自动去相应的func.c模块查找foo的地址，然后将main.c模块中所有引用到foo的指令重新修正，让它们的目标地址为真正的foo函数的地址。这就是静态链接的最基本的过程和作用。
</code></pre><p>备注：本文摘自《程序员的自我修养：链接、装载与库》俞甲子</p>
<h6 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h6><p>本文由<a href="xingdi.me">邢迪</a>创作和发表，采用<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br>本文链接：<a href="http://xingdi.me/2017/01/17/编译和链接做了什么/">http://xingdi.me/2017/01/17/编译和链接做了什么/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代码由人类可读语言变为机器可读，需要经历以下几个步骤&lt;/p&gt;
&lt;p&gt;&lt;code&gt;预处理-&amp;gt;编译-&amp;gt;汇编-&amp;gt;链接&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个过程在我们目前的开过中，基本都由IDE来完成了，以Xcode为例，我们还能在Run一个程序的过程中，看到提示进入
    
    </summary>
    
    
      <category term="编译" scheme="http://xingdi.me/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="链接" scheme="http://xingdi.me/tags/%E9%93%BE%E6%8E%A5/"/>
    
      <category term="Propressing" scheme="http://xingdi.me/tags/Propressing/"/>
    
      <category term="Linking" scheme="http://xingdi.me/tags/Linking/"/>
    
  </entry>
  
  <entry>
    <title>开始使用markDown</title>
    <link href="http://xingdi.me/2017/01/11/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8markDown/"/>
    <id>http://xingdi.me/2017/01/11/开始使用markDown/</id>
    <published>2017-01-11T06:59:41.000Z</published>
    <updated>2017-02-28T03:36:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>决定开始使用markdown来写文章，这里记录下一些常用用方，以便以后写作需要时参考，会陆续纳入用到的一些语法和效果展示。</p>
<h4 id="第一目标是标题"><a href="#第一目标是标题" class="headerlink" title="第一目标是标题"></a>第一目标是标题</h4><ul>
<li><p><code>以上是####的效果，一个#最大，到六个#最小</code></p>
</li>
<li><h6 id="六个-的效果"><a href="#六个-的效果" class="headerlink" title="六个#的效果"></a>六个#的效果</h6></li>
<li><p><code>下面是代码块效果，三个</code></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">这是在代码块中的内容</div><div class="line">可以换行</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="代码块中的语法高亮效果"><a href="#代码块中的语法高亮效果" class="headerlink" title="代码块中的语法高亮效果"></a>代码块中的语法高亮效果</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *tmp = <span class="string">@"hello"</span>;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"这是一个高亮测试%@"</span>,tmp);</div></pre></td></tr></table></figure>
<p>可能在编辑器中看不到实时预览效果，我们将在blog上进行验证，实现如下：</p>
<pre><code><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *tmp = <span class="string">@"hello"</span>;</div></pre></td></tr></table></figure>
</code></pre><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p>如果需要展示数据什么的，可以选择使用表格</p>
<table>
<thead>
<tr>
<th>header 1</th>
<th>header 3</th>
</tr>
</thead>
<tbody>
<tr>
<td>cell 1</td>
<td>cell 2</td>
</tr>
<tr>
<td>cell 3</td>
<td>cell 4</td>
</tr>
<tr>
<td>cell 5</td>
<td>cell 6</td>
</tr>
</tbody>
</table>
<pre><code>实现如下。好像编辑器也无法预览表格效果
| header 1 | header 3 |
| -------- | -------- |
| cell 1   | cell 2   |
| cell 3   | cell 4   |
| cell 5   | cell 6   |
</code></pre><h4 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h4><p>生成一个脚注[^footnote].<br>[^footnote]: 这里是 <strong>脚注</strong> 的 <em>内容</em>.<br>生成第二个脚注[^2].<br>[^2]: 这里是 <strong>第二个脚注</strong> 的 <em>内容</em>.</p>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>用 <code>[TOC]</code>来生成目录：</p>
<p>[TOC]</p>
<p>注：脚注和目录TOC功能hexo暂不支持</p>
<h4 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h4><ul>
<li>列表的作用<ul>
<li>实现段落感</li>
<li>二级段落下面是一个tab位置<ul>
<li>三级段落再加一个tab位置</li>
<li>同样是三级段落</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>下面是上面效果的原文</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- 列表的作用</div><div class="line">	- 实现段落感</div><div class="line">	- 二级段落下面是一个tab位置</div><div class="line">		- 三级段落再加一个tab位置</div><div class="line">		- 同样是三级段落</div></pre></td></tr></table></figure>
<p>也可以用* + - （星号，加号，减号）</p>
<ul>
<li>这是一个段落</li>
<li>这是另一个</li>
<li>效果如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*   这是一个段落</div><div class="line">*   这是另一个</div></pre></td></tr></table></figure>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是一个[链接](xingdi.me)</div></pre></td></tr></table></figure>
<p>这是一个<a href="xingdi.me">链接</a>,在macDown编辑器中可以直接将文字选中，按快捷键command+shift+k来生成链接格式，只需要在小括号中填入链接地址即可</p>
<h4 id="图片引用"><a href="#图片引用" class="headerlink" title="图片引用"></a>图片引用</h4><p>图片引用使用<code>![]()</code>的方式<br><img src="http://siwangxinyuan.qiniudn.com/jianshu-42-1280x800-%5BDesktopNexus.com%5D.jpg?imageView/2/w/640/q/90" alt="图片测试"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![图片测试](http://siwangxinyuan.qiniudn.com/jianshu-42-1280x800-%5BDesktopNexus.com%5D.jpg?imageView/2/w/640/q/90)</div></pre></td></tr></table></figure>
<p>上图中的7牛图床链接，640为图片的宽度，可以自定义设置</p>
<h6 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h6><p>本文由<a href="xingdi.me">邢迪</a>创作和发表，采用<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br>本文链接：<a href="http://xingdi.me/2017/01/11/开始使用markDown/">http://xingdi.me/2017/01/11/开始使用markDown/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;决定开始使用markdown来写文章，这里记录下一些常用用方，以便以后写作需要时参考，会陆续纳入用到的一些语法和效果展示。&lt;/p&gt;
&lt;h4 id=&quot;第一目标是标题&quot;&gt;&lt;a href=&quot;#第一目标是标题&quot; class=&quot;headerlink&quot; title=&quot;第一目标是标题&quot;&gt;
    
    </summary>
    
    
      <category term="markdown" scheme="http://xingdi.me/tags/markdown/"/>
    
      <category term="macdown" scheme="http://xingdi.me/tags/macdown/"/>
    
      <category term="blog" scheme="http://xingdi.me/tags/blog/"/>
    
      <category term="开发记录" scheme="http://xingdi.me/tags/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>helloHexo</title>
    <link href="http://xingdi.me/2017/01/09/helloHexo/"/>
    <id>http://xingdi.me/2017/01/09/helloHexo/</id>
    <published>2017-01-09T09:48:54.000Z</published>
    <updated>2017-01-09T09:49:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>2017狠下心买了域名，虽然没多少钱。<br>以后博客就在这里了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017狠下心买了域名，虽然没多少钱。&lt;br&gt;以后博客就在这里了。&lt;/p&gt;

    
    </summary>
    
    
      <category term="随笔" scheme="http://xingdi.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
